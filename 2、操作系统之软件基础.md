 

一、硬件支持系统 ，系统管理硬件
----------------

*   **操作系统核心功能**可以分为：
    *   **守护者**：对硬件和软件资源的管理
    *   **协调者**：通过机制，将各种各样的硬件资源适配给软件使用。
*   所以**为了更好的管理硬件，操作系统引进了软件**。其中**3大核心部分**是：
    *   文件【我们需要知道怎么用文件来访问磁盘和I/O设备】
    *   虚拟内存【虚拟内存是虚拟的，**为应用程序提供远大于物理内存限制的虚拟地址空间**。】
    *   进程【真正用来访问资源的部分】  
        ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5a9d2157b36642178b5bab1d15d107b9.png)

二、进程（process）
-------------

### 1、理解

进程就是一个**正在执行的程序实例**。

> 进程的结构
> 
> *   每个进程里都有一个`独立的地址空间`。
>     *   这个空间一开始是0 ，不断的运行，就成了连续的存储空间。在这个空间，不仅程序能运行起来，还能调用各种数据，等等。
> *   每个进程都有相关的`资源`
>     *   这些资源有PS ， PC寄存器等等。
> 
> **简而言之**：进程就是一个被封装的容器，它有运行资源的一切信息。

*   如果 我开了QQ，又开了微信。那我的进程就有2个，它要如何**合理地获得CPU资源**？
    
    *   **操作系统通过时间片轮转等调度策略**，**周期性地挂起**一个进程并**启动**另一个，确保所有进程都能公平地获得CPU资源。
    *   当进程被**暂时挂起**，就必须保存状态了。以便未来某个时候可以继续使用。状态下的信息【比如寄存器，地址空间，上下文等等】都会被存储在`进程表`中。
        *   **`进程表`用于跟踪系统中所有进程的状态信息**。
*   **shell和进程**
    *   用户可以使用shell来控制进程。让一个进程产生更多进程（这些由进程产生的进程就是`子进程`）【可能有些抽象，可以这样理解，如下：】。
        *   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/909049aa3b0a44eb91366c379564b4cb.png)
        *   我在shell使用`ls` 命令，这个命令展现了当前路径有的文件件。我本来是在运行shell的linux环境虚拟机【当前一个主进程】，我想看文件夹，我为了看文件夹，使用了ls命令，在执行这个ls命令的过程就是`子进程`。
    *   所以进程就有树的样子了-----`进程树`。
    *   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/572a2f8139ff4646b92e4658ba331380.png)
*   **进程该如何通信**？
    
    *   当进程间协同工作完后，使用机制来交换信息，也就是`进程间通信（IPC）` 机制。
    *   除了`进程间通信（IPC）`外，操作系统还使用一系列的`系统调用`来管理进程资源。
*   **进程接收信息，如果信息经常不能准时到达**？
    *   为了确保可靠传输，进程会采用`定时器`。【这种行为也就是异步】
        *   比如：进程在外部信息发送出去的第4秒还没有接收到。就发一个通知提醒，就可能重新发送了。

> **异步行为**【分为软件异步、硬件异步】：  
> 异步行为是指任务可以并发执行，不需要等待前一个任务完成。异步操作不会阻塞当前线程，任务完成后通过回调、Promise 或事件通知。

- 用户态和内核态用中断进行切换，那么中断的过程是什么样子？

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c3959991b7c74b7db28b09b282372ff1.png)

*   那么事件1发生什么事情？
    *   **事件1作用：保护现场**。（**如果后续需要回到这个原来位置，就需要保护现场的作用。以便于恢复到原来位置。**）
    *   **用于保护的内容有**
        *   PC值----**由CPU保护**
        *   PSW寄存器（**用于存储当前程序的运行状态和控制信息**。）—**OS保护**
        *   基础寄存器—**OS保护**
        *   **不过在现代有可以都用CPU保护的了**。如：CortexM芯片等等。
*   事件2发生什么事情？
    *   事件2作用：**确定中断入口在哪里**
    *   硬件CPU来准备—操作系统OS和硬件CPU都能来提供`中断向量表【中断处理函数的数组空间。根据中断号定位对应的中断服务程序。】`。（硬件提供这个是书上没有的，但是有相关论文提到。做题就当成是OS提供。）
*   事件3发生什么事情？
    *   事件3作用：**中断处理函数执行中断服务程序**
    *   操作系统来准备。
*   事件4发生什么事情？
    *   事件4作用：**中断返回**【**普通函数**返回】
    *   **软件实现，编译器来实现**。
    *   特定的汇编写，不能c语言。
        *   普通函数
            *   PC值—>硬件保护
            *   PSW寄存器—>不需要保护。
            *   基础寄存器—>编译器保护

> **同步行为**  
> 同步行为是指**任务按顺序执行**，前一个任务完成后，才能开始下一个任务。同步操作会阻塞当前线程，直到任务完成。

三、内存和虚拟内存【重点，面试问的多】
------

### 1、了解内存布局

![image-20250618223834447](C:\Users\LEGION\AppData\Roaming\Typora\typora-user-images\image-20250618223834447.png)

从下往上看，分为进程代码和数据区、堆数据区、共享库区、堆栈区、内核内存区。

这部分的基础先了解这个图片就行了。

> 常驻内存是指一直都在，不能删掉。

### 2、什么是栈和什么是堆？

- 栈是由**操作系统自动分配和释放的，里面存储的内容有函数参数、局部变量等等。并且局部变量是按照先后定义的顺序依次压入栈的。**
- 堆是**由人自动申请和释放的，不主动释放会内存泄漏**。

### 3、栈和堆的区别

- ①`管理方式`：就是第2点的内容。
- ②`空间大小`：栈的空间远小于堆，一般只有8M。
- ③`生长方向大小不同`：栈的生长方向是向下的，内存地址由高到低。堆是向上的，内存地址由低到高。
- ④`分配方式不同`：堆都是动态分配的。而栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统来完成，比如：局部变量。动态分配是由alloca
- ⑤`分配效率不同`：
- ⑥`存放内容不同`：栈是函数的返回地址，函数参数，局部变量等等。堆是程序员决定。

### 4、栈和堆发生错误

- 栈是函数递归无终止条件，数组越界。
- 堆是内存泄漏，使用释放的内存。

### 5、栈和堆来自哪个数据结构

- 堆是高地址扩展的数据结构，**是不连续的内存区域**。是由于系统是**用链表**来存储的空闲内存地址，是自然是不连续的，**而链表的遍历方向是由地址向高地址**。

- 栈是**线性表**，并且将线性表的插入和删除操作限制仅为表的一段进行，通常将表中运行进行插入、删除操作的一端叫**栈顶**。

四、并发和并行
-------

* **并发**是指多个任务在**同一时间段内交替执行**，**但在任意时刻可能只有一个任务在运行**。并发通过任务切换（**上下文切换**）实现，给人一种多个任务同时运行的错觉。

  > **上下文切换**：对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。**它能将 CPU 资源从一个进程分配给另一个进程的机制**。从用户角度看，**计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果**。在**切换的过程中**，操作系统需要**先存储当前进程的状态** (包括内存空间的指针，当前执行完的指令等等)，**再读入下一个进程的状态**，**然后执行此进程**。[推荐这个文章，来自于这里](https://blog.csdn.net/qq_36894974/article/details/115654242?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522f4701778eeda4cb106e161aff526d0c4%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=f4701778eeda4cb106e161aff526d0c4&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115654242-null-null.142^v102^pc_search_result_base9&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95&spm=1018.2226.3001.4187)
* 如图：同一时间段内

```bash
时间轴： |----任务A----|----任务B----|----任务A----|----任务B----|
```

*   **并行**是指**多个任务在同一时刻同时执行**。**并行需要多核 CPU 或多个处理器，每个任务运行在不同的核心上**。
*   如图：同一时刻内

```bash
时间轴： |----任务A----|
          |----任务B----|
          	 |----任务C----|
```

五、系统调用【超重点】
-----------

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/21678089719a4da1bba7886befe55ff7.png)

> 通过上图能明白，硬件不能直接让用户使用它。  
> 所以提出了`系统调用` 。

*   [系统调用（可以看看这篇文章）](https://blog.csdn.net/2301_80355452/article/details/147722660?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-4-147722660-blog-102841078.235%5Ev43%5Epc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-4-147722660-blog-102841078.235%5Ev43%5Epc_blog_bottom_relevance_base2&utm_relevant_index=8)
    *   定义：**系统调用是操作系统内核（Kernel）为应用程序提供的一组接口**，**允许用户程序（运行在用户态）请求内核（运行在内核态，如果看过第一篇文章，是能理解到的。）代为执行特权操作**（如文件读写、进程创建等）。
    *   系统调用**依赖硬件和OS（操作系统）**。
    
*   **系统调用的工作原理**
    
*   (1) 调用流程
    
    *   **用户程序触发调用**
        *   通过**特定函数**（如C标准库中的 printf() → 底层调用 write()）或直接代码**触发**。
    *   **用户态 → 内核态切换**
        *   通过**软中断**（如 int 0x80）或专用指令（如 syscall）**进入内核态**。
    *   **执行内核服务**
        *   内核根据系统调用号（如 Linux 的 read 对应 0 号）调用对应的内核函数。
    *   **返回结果**
        *   内核将结果传递给用户程序，**回到用户态**继续执行。
*   (2) 系统调用号（syscall number）（了解即可）
    
    *   **每个系统调用对应唯一编号**，通过**寄存器传递**（如 x86-64 Linux 中，rax 存放系统调用号）。
    *   示例：Linux 的 sys\_write 在 x86-64 中的调用号是 1，可通过命令 grep \_\_NR\_write /usr/include/asm/unistd\_64.h 查看。
*   (3) 参数传递（了解即可）
    
    *   寄存器传递参数：参数按顺序放入 rdi, rsi, rdx, r10, r8, r9（x86-64 架构）。  
        ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6b8e1bd2bddb4b9287ad0d4f5bb2a822.png)

## 六、中断和系统调用的区别？

- 中断：由硬件或异常触发，强制切换上下文。
- 系统调用：程序主动发起，通过软中断进入内核。

本文转自 <https://blog.csdn.net/2401_82911768/article/details/146295491?sharetype=blogdetail&sharerId=146295491&sharerefer=PC&sharesource=2401_82911768&spm=1011.2480.3001.8118>，如有侵权，请联系删除。